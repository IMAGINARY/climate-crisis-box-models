function t(){return(t=Object.assign||function(t){for(var n=1;n<arguments.length;n++){var r=arguments[n];for(var a in r)Object.prototype.hasOwnProperty.call(r,a)&&(t[a]=r[a])}return t}).apply(this,arguments)}function n(t,n,r,a){var o=a(t,n);return t.map(function(n,a){return t[a]+r*o[a]})}function r(t,n,r,a){for(var o=t.length,e=a(t,n),i=Array(o),s=r/2,u=r/6,c=n+s,f=0;f<o;f+=1)i[f]=t[f]+s*e[f];for(var d=a(i,c),l=0;l<o;l+=1)i[l]=t[l]+s*d[l];for(var h=a(i,c),v=0;v<o;v+=1)i[v]=t[v]+r*h[v],h[v]+=d[v];return d=a(i,n+r),t.map(function(n,r){return t[r]+u*(e[r]+d[r]+2*h[r])})}var a=function(){function n(a,o){var e=a.stocks,i=a.flows,s=a.variables,u=a.constants;void 0===o&&(o=r),this.stocks=e,this.flows=i,this.variables=s,this.constants=u,this.integrator=o,this.ensureUniqueIds(),this.idToIdx=t({},n.createIdToIdxMap(e),n.createIdToIdxMap(s),n.createIdToIdxMap(u),n.createIdToIdxMap(i))}var a=n.prototype;return a.ensureUniqueIds=function(){var t=[].concat(this.stocks,this.variables,this.constants,this.flows).map(function(t){return t.id}).reduce(function(t,n,r,a){return a.lastIndexOf(n)!==r&&a.push(n),t},[]);if(t.length>0)throw new Error("Duplicate ids found: "+t)},n.createIdToIdxMap=function(t){var n={};return t.forEach(function(t,r){return n[t.id]=r}),n},a.evaluateGraph=function(t,n){var r=this,a=function(n){return t[r.idToIdx[n]]},o=this.constants.map(function(t){return t.value}),e=function(t){return o[r.idToIdx[t]]},i=function(t){var o=new Array(t.length);return{evaluator:function(i){var s=r.idToIdx[i];if(null===o[s])throw new Error("Evaluation cycle detected starting at: ${id}");return void 0===o[s]&&(o[s]=null,o[s]=t[s].equation(a,d,u,e,n)),o[s]},data:o}},s=i(this.variables),u=s.evaluator,c=s.data,f=i(this.flows),d=f.evaluator,l=f.data;return this.variables.forEach(function(t){return u(t.id)}),this.flows.forEach(function(t){return d(t.id)}),{stocks:t,flows:l,variables:c,constants:o}},a.step=function(t,n,r){return this.stepExt(t,n,r).stocks},a.stepExt=function(t,n,r){var a=this,o=this.integrator(t,n,r,function(t,n){var r=a.evaluateGraph(t,n).flows,o=function(t){return r[a.idToIdx[t]]},e=function(t){return t.map(function(t){return o(t)}).reduce(function(t,n){return t+n},0)};return t.map(function(t,n){return e(a.stocks[n].in)-e(a.stocks[n].out)})}),e=this.evaluateGraph(o,n+r);return{stocks:o,variables:e.variables,constants:e.constants,flows:e.flows}},n}();export{a as BoxModel,n as euler,r as rk4};
//# sourceMappingURL=box-model.module.js.map
